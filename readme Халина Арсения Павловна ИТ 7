Халина Арсения Павловна ИТ-7
Задача, вариант 2
Игра в слова. Дан набор слов. Известно, что эти слова использовались для 
игры, в которой очередное слово должно заканчиваться той буквой, на 
которую закончилось предыдущее слово. С какого слова начинается игра, не 
имеет значения. Если слово оканчивается на «ь», то используется предыдущая 
буква. Последнее слово цепочки должно заканчиваться буквой первого слова 
цепочки. Входной файл содержит все слова в одной строке, слова записаны 
строчными буквами русского алфавита, между словами может быть один или 
более пробелов. Требуется выстроить данные слова в цепочку согласно 
правилам игры. Достаточно найти одно подходящее решение. Возможен 
вариант, что решений не существует.  
Пример 1: 
(файл входных данных) 
хмель мороз налог лимон запах дым лошадь холм гол молох 
(файл выходных данных) 
налог гол лошадь дым мороз запах холм молох хмель лимон 
Пример 2:  
(файл входных данных) 
аквариум сирень жатва заноза нож авось тормоз мост 
(файл выходных данных) 
авось сирень нож жатва аквариум мост тормоз заноза 



Структура данных
1.	Граф: Использование ориентированного графа позволяет эффективно представить отношения между словами, учитывая первую и последнюю буквы каждого слова. Этот подход облегчает применение известных алгоритмов поиска циклических маршрутов, таких как алгоритм Hierholzera.
2.	Степень вершин: Для эффективного определения наличия Эйлерова пути необходим подсчёт входящей и исходящей степени каждой вершины (первая и последняя буквы слов). Эти данные позволяют определить точки входа и выхода в графе, необходимые для нахождения эйлерового цикла.
3.	Связи: Дополнительная структура (ассоциативный массив), хранящая конкретные слова, помогает быстро восстанавливать саму цепочку слов после нахождения подходящего маршрута.

Обработка исключений
Обработка исключений применяется в нескольких ключевых местах:
1.	Проверка ввода: Пользовательские данные проходят проверку регулярным выражением, чтобы убедиться, что введены только русские буквы. Исключительные ситуации возникают, если пользователь вводит недопустимые символы или пустые строки.
2.	Невозможность построения цепи: Программа проверяет существование эйлерова цикла. Если условия для его существования нарушены (например, несоответствие степеней вершин), выводится исключение с соответствующим сообщением.
3.	Отсутствие допустимых решений: Если ни одна комбинация не удовлетворяет условиям задачи, программа также генерирует специальное исключение.
Основные компоненты системы
Проект организован в виде классов и методов, обеспечивающих модульность и повторное использование кода.

Классы и методы
1.	Queue
•	Реализует простую структуру очереди FIFO (First-In-First-Out).
•	Методы: append, popleft, peek, is_empty.
2.	GraphBuilder
•	Строит граф на основе списка слов.
•	Метод: build — преобразует список слов в граф.
3.	PathFinder
•	Осуществляет поиск путей в графе методом Hierholzera.
•	Ключевой метод: hierholzer — реализует сам алгоритм поиска Эйлерова цикла.
4.	Validator
•	Проверяет правильность введённых пользователем данных.
•	Метод: validate_input — разбивает строку на слова и применяет регулярные выражения для проверки.
5.	AppController
•	Управляет основным потоком приложения, принимает ввод от пользователя, запускает обработку и отображает результат.
•	Главный метод: run — организует процесс взаимодействия с пользователем.

Описание реализации
1.	Нормализация слов
Процедура нормализации определяет первую и последнюю буквы слова специальным образом. Если слово заканчивается мягким знаком ('ь'), то вместо последнего символа берется предыдущий.
2.	Создание графа
Каждая буква слова рассматривается как вершина графа. Рёбра формируются путем соединения первой буквы текущего слова с последней буквой следующего. Количество входов и выходов из каждой вершины фиксируется.
3.	Поиск Эйлерова цикла
Метод Hierholzera последовательно исследует каждую связь, отмечая пройденные пути. Цель — пройти каждый участок графа ровно один раз, возвращаясь обратно в стартовую позицию.

Пример хода метода:
Начинаем с произвольной вершины.
Следуем по ещё неиспользованным рёбрам.
Повторяем до тех пор, пока не будут исчерпаны все рёбра.
Формирование цепочки слов
Полученный путь по графу сопоставляется с фактическими словами, формируя итоговую цепочку.

Инкапсуляция, наследование и полиморфизм
•	Инкапсуляция: Каждый класс скрывает свою внутреннюю структуру данных и предоставляет публичные интерфейсы для взаимодействия. Например, класс GraphBuilder инкапсулирует создание графа, обеспечивая прозрачность его внутреннего устройства.
•	Наследование: Прямого наследования в проекте нет, поскольку каждая сущность имеет достаточно независимую функциональность. Однако косвенно классы реализуют общий интерфейс взаимодействия, создавая аналогию виртуального базового класса (интерфейса).
•	Полиморфизм: Хотя прямого полиморфизма нет, разные объекты могут вызывать общие методы схожего назначения (например, различные виды обработки ошибок).
